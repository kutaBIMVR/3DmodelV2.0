<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å¹²æŒ‚çŸ³æèŠ‚ç‚¹ Â· æ„é€ è®¤çŸ¥ä¸æ‹†è£…æ•™å­¦</title>
    <!-- ä½¿ç”¨ç¨³å®šç‰ˆæœ¬çš„Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        /* ===== å…¨å±€é‡ç½®ä¸å­—ä½“ ===== */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Microsoft YaHei', 'PingFang SC', 'Segoe UI', sans-serif;
            overflow: hidden;
            background-color: #0a0e14;
            color: #fff;
        }

        /* ===== ç”»å¸ƒå®¹å™¨ï¼šå…¨å±ï¼Œæ·±ç©ºæ¸å˜èƒŒæ™¯ ===== */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at 30% 40%, #1c2330, #0b0d13);
            overflow: hidden;
        }

        /* ===== å·¦ä¾§æ‚¬æµ®æ§åˆ¶é¢æ¿ï¼ˆæ¯›ç»ç’ƒæ•ˆæœï¼‰===== */
        #control-panel {
            position: absolute;
            left: 24px;
            top: 24px;
            width: 320px;
            background: rgba(12, 20, 30, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 28px;
            padding: 24px 22px;
            color: #f0f6fc;
            border: 1px solid rgba(80, 160, 255, 0.35);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            z-index: 100;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            pointer-events: auto;
            scrollbar-width: thin;
            scrollbar-color: #3a7ca5 #1a2530;
        }

        #control-panel::-webkit-scrollbar {
            width: 5px;
        }
        #control-panel::-webkit-scrollbar-thumb {
            background: #3a7ca5;
            border-radius: 10px;
        }

        /* ===== æ ‡é¢˜åŒº ===== */
        h2 {
            margin: 0 0 8px 0;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ffd966;
            border-bottom: 2px solid #3a7ca5;
            padding-bottom: 16px;
            letter-spacing: 1px;
        }

        .subtitle {
            background: rgba(0, 0, 0, 0.35);
            border-left: 6px solid #ffaa00;
            padding: 14px 16px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.7;
            color: #d4e6ff;
            margin: 16px 0 8px 0;
        }

        /* ===== å±‚æ¬¡æŒ‰é’®ç»„ ===== */
        .section-title {
            font-size: 17px;
            font-weight: 600;
            margin: 24px 0 12px 0;
            color: #b3e4ff;
            border-left: 5px solid #ffaa00;
            padding-left: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .layer-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 10px;
        }

        .layer-btn {
            background: rgba(25, 45, 65, 0.9);
            border: 1px solid #3f6a8c;
            color: #ecf5ff;
            padding: 8px 18px;
            border-radius: 40px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
        }

        .layer-btn:hover {
            background: #2e5e7e;
            border-color: #ffc107;
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(255,170,0,0.3);
        }

        .layer-btn.active {
            background: #ffaa00;
            color: #0a1a2a;
            border-color: #ffffff;
            font-weight: bold;
            box-shadow: 0 0 20px #ffaa00cc;
        }

        /* ===== æ‹†è£…æ“ä½œæŒ‰é’® ===== */
        .assembly-group {
            display: flex;
            gap: 16px;
            margin-top: 10px;
            margin-bottom: 8px;
        }

        .action-btn {
            background: #1f3e55;
            border: none;
            color: white;
            padding: 12px 16px;
            border-radius: 36px;
            font-size: 15px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: 0.2s;
            font-weight: 600;
            border-bottom: 4px solid #0e2f40;
            letter-spacing: 1px;
        }

        .action-btn:hover {
            background: #2e6a8c;
            border-bottom-color: #ffaa00;
            transform: scale(1.02);
        }

        /* æ»‘åŠ¨æ¡åŒºåŸŸ */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 15px 0 5px;
            background: #0e1e2a;
            padding: 10px 16px;
            border-radius: 32px;
            border: 1px solid #3a7ca5;
        }
        .slider-container label {
            color: #c2d9f0;
            font-size: 14px;
            white-space: nowrap;
        }
        #explode-slider {
            width: 100%;
            accent-color: #ffaa00;
            background: #1a2f3a;
            height: 6px;
            border-radius: 10px;
        }

        /* ===== å›¾æ–‡è¯´æ˜å¡ç‰‡ ===== */
        #construction-desc {
            background: #0e1e2a;
            padding: 18px;
            border-radius: 20px;
            border-left: 10px solid #6b7c8b;
            margin: 18px 0 10px 0;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
            line-height: 1.7;
        }

        #construction-desc strong {
            color: #ffd966;
            font-size: 17px;
        }

        #extra-desc {
            color: #c2d9f0;
            font-size: 14px;
        }

        /* å›¾ç‰‡å¼¹çª—æŒ‰é’® */
        .img-popup-btn {
            background: #2e6a8c;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 40px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 12px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: 0.2s;
            border-bottom: 3px solid #0e4a5c;
        }
        .img-popup-btn:hover {
            background: #3f8bb0;
            border-bottom-color: #ffaa00;
        }

        /* ===== è¯•é¢˜åŒºåŸŸ ===== */
        .quiz-area {
            background: rgba(8, 20, 30, 0.7);
            border-radius: 24px;
            padding: 20px;
            margin-top: 25px;
            border: 1px solid #4f9e9e;
            backdrop-filter: blur(5px);
        }

        .question {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 18px;
            color: #ffe08c;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .option-item {
            background: rgba(40, 65, 90, 0.8);
            padding: 12px 18px;
            border-radius: 30px;
            border: 1px solid #3a7899;
            cursor: pointer;
            transition: 0.1s;
            font-size: 15px;
            color: #f0f9ff;
        }

        .option-item:hover {
            background: #2c6c8c;
            border-color: #ffaa00;
        }

        .option-item.selected {
            background: #0f6b7c;
            border: 2px solid #ffc107;
            font-weight: 500;
        }

        #quiz-feedback {
            margin-top: 16px;
            padding: 14px;
            border-radius: 16px;
            background: rgba(0,0,0,0.45);
            color: #e2f0fa;
            border-left: 8px solid #ffaa00;
            font-style: italic;
            font-size: 14px;
        }

        /* ===== åº•éƒ¨çŠ¶æ€æ¡ ===== */
        #status-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(8, 18, 28, 0.9);
            backdrop-filter: blur(12px);
            padding: 14px 34px;
            border-radius: 60px;
            border: 1px solid #2f80b0;
            box-shadow: 0 0 30px #0066aa60;
            color: #b8f2ff;
            font-size: 16px;
            z-index: 200;
            display: flex;
            align-items: center;
            gap: 14px;
            border-bottom: 5px solid #00ccff;
            letter-spacing: 1.5px;
        }

        #voice-hint {
            position: absolute;
            bottom: 130px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(6px);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            color: #ffd985;
            border: 1px solid #ffaa00;
            z-index: 150;
            pointer-events: none;
            box-shadow: 0 0 20px #ff990055;
        }

        .hint-note {
            position: absolute;
            bottom: 130px;
            left: 380px;
            color: rgba(210, 235, 255, 0.8);
            font-size: 13px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 22px;
            border-radius: 40px;
            backdrop-filter: blur(4px);
            border: 1px dashed #8ac4ff;
            pointer-events: none;
        }
        /* å³ä¸‹è§’ç‰ˆæœ¬å· */
        .version-tag {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(6px);
            color: #cce6ff;
            padding: 10px 24px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            border: 1px solid #3a9ad9;
            box-shadow: 0 0 20px #004c99;
            z-index: 250;
            letter-spacing: 2px;
            border-bottom: 5px solid #ffaa00;
        }
    </style>
</head>
<body>

    <!-- Three.js ç”»å¸ƒå®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- å·¦ä¾§æ™ºèƒ½æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
<h2>ğŸ§± å¹²æŒ‚çŸ³æ Â· èŠ‚ç‚¹æ„é€ </h2>
<div class="subtitle">
    ğŸ“ æŒ‰Maxå‘½åè‡ªåŠ¨åŒ¹é…ï¼šåŸºå±‚å¢™ä½“ã€é¢„åŸ‹ä»¶ã€ç«–å‘é¾™éª¨ã€æ¨ªå‘é¾™éª¨ã€ä¿æ¸©å±‚ã€çŸ³ææŒ‚ä»¶ã€çŸ³æé¢æ¿ã€å¯†å°èƒ¶<br>
    ğŸ¯ ç‚¹å‡»å±‚æ¬¡â†’é«˜äº®æ˜¾ç¤ºï¼Œå…¶ä½™åŠé€æ˜ï¼›å†æ¬¡ç‚¹å‡»å–æ¶ˆé«˜äº®ã€‚<br>
    ğŸ”ˆ ç‚¹å‡»æŒ‰é’®å³è‡ªåŠ¨è¯­éŸ³è®²è§£è¯¥æ„ä»¶ã€‚<br>
    <button id="img-popup-btn" class="img-popup-btn" style="margin-top:12px; background:#2e6a8c; border:none; color:white; padding:10px 20px; border-radius:40px; display:inline-flex; align-items:center; gap:8px; cursor:pointer;">ğŸ–¼ï¸ ç‚¹å‡»æŸ¥çœ‹æ„é€ è¯¦å›¾</button>
</div>

        <!-- å±‚æ¬¡æ„é€ æŒ‰é’®ï¼ˆç”±JSåŠ¨æ€ç”Ÿæˆï¼‰ -->
        <div class="section-title">ğŸ” æ„é€ å±•ç¤ºï¼ˆé«˜äº®/è¯­éŸ³ï¼‰</div>
        <div id="layer-buttons-container" class="layer-buttons"></div>

        <!-- æ‹†è£…æ§åˆ¶ï¼šæ»‘åŠ¨æ¡çˆ†ç‚¸æ‹†åˆ† + ç»„è£… -->
        <div class="section-title">ğŸ§© æ„é€ æ‹†è£…ï¼ˆåŸç‚¹çˆ†ç‚¸ï¼‰</div>
        <div class="assembly-group">
            <button id="btn-split" class="action-btn"><span style="font-size:1.2em;">ğŸ’¥</span> çˆ†ç‚¸æ‹†åˆ†</button>
            <button id="btn-assemble" class="action-btn"><span style="font-size:1.2em;">ğŸ”¹</span> ä¸€é”®ç»„è£…</button>
        </div>
        <!-- æ»‘åŠ¨æ¡æ§åˆ¶çˆ†ç‚¸è·ç¦» -->
        <div class="slider-container" id="slider-container" style="display: none;">
            <label>ğŸ’¢ çˆ†ç‚¸è·ç¦»</label>
            <input type="range" id="explode-slider" min="0" max="10" step="0.01" value="1.2">
        </div>

        <!-- å›¾æ–‡è¯´æ˜ + å›¾ç‰‡å¼¹çª—æŒ‰é’® -->
        <div class="section-title">ğŸ“˜ å›¾æ–‡è¯´æ˜</div>
        <div id="construction-desc">
            <strong>åŸºå±‚å¢™ä½“</strong>ï¼šç°è‰²ï¼Œç»“æ„åŸºç¡€<br>
            <span id="extra-desc">ç‚¹å‡»å±‚æ¬¡æŸ¥çœ‹è¯¦ç»†æ„é€ ä¸é¢œè‰²</span>
        </div>


        <!-- è¯•é¢˜è€ƒæ ¸ -->
        <div class="quiz-area">
            <div class="question">ğŸ“Œ è¯•é¢˜ï¼šå¹²æŒ‚çŸ³æèŠ‚ç‚¹ä¸­ï¼Œä¸»è¦æ‰¿å—è·è½½å¹¶å°†åŠ›ä¼ é€’åˆ°ä¸»ä½“çš„å…³é”®è¿æ¥æ„ä»¶æ˜¯ï¼Ÿ</div>
            <div id="options-container" class="options">
                <div class="option-item" data-index="0">A. çŸ³æé¢æ¿</div>
                <div class="option-item" data-index="1">B. ç«–å‘é¾™éª¨</div>
                <div class="option-item" data-index="2">C. çŸ³ææŒ‚ä»¶</div>
                <div class="option-item" data-index="3">D. å¯†å°èƒ¶</div>
            </div>
            <div id="quiz-feedback" class="feedback">ğŸ’¡ è¯·é€‰æ‹©ä¸€ä¸ªé€‰é¡¹</div>
        </div>
        <p style="font-size:12px; color:#aac; text-align:right; margin-top:12px;">ğŸ”Š è¯­éŸ³åŸºäºWeb Speech API Â· æ„é€ è®¤çŸ¥ä¸“ç”¨</p>
    </div>

    <!-- çŠ¶æ€æç¤ºæ¡ -->
    <div id="status-bar">
        <span id="status-icon">âš™ï¸</span>
        <span id="status-text">åˆå§‹åŒ– Three.js ...</span>
    </div>
    <div id="voice-hint">ğŸ”Š ç‚¹å‡»å±‚æ¬¡æŒ‰é’®è‡ªåŠ¨è¯­éŸ³è®²è§£</div>
    <div class="hint-note">ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§» | è‡ªåŠ¨æ—‹è½¬å·²å…³é—­</div>
    


    <script type="module">
        // =========================================================================
        // å¹²æŒ‚çŸ³æèŠ‚ç‚¹æ„é€ æ•™å­¦ç³»ç»Ÿ â€”â€” ä¿®å¤ç‰ˆ
        // ä¿®å¤ï¼šæ‰€æœ‰å±‚çº§é€æ˜é«˜äº®ã€çˆ†ç‚¸åŸºäºåŸç‚¹æ”¾å°„ã€å›¾ç‰‡æŒ‰é’®ç§»è‡³æ ‡é¢˜ä¸‹
        // =========================================================================
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // ---------- 1. åˆå§‹åŒ–åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨ ----------
        const container = document.getElementById('canvas-container');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101a24);
        
        const camera = new THREE.PerspectiveCamera(48, container.clientWidth / container.clientHeight, 0.01, 1000);
        camera.position.set(7, 5, 14);
        camera.lookAt(0, 1.5, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);
        
        // ---------- 2. æ§åˆ¶å™¨ (å…³é—­è‡ªåŠ¨æ—‹è½¬) ----------
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = false;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.target.set(0, 1.5, 0);
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 3;
        controls.maxDistance = 200;
        
        // ---------- 3. ç¯å…‰ç³»ç»Ÿ ----------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffeedd, 1.4);
        mainLight.position.set(4, 8, 10);
        mainLight.castShadow = true;
        mainLight.receiveShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        mainLight.shadow.camera.near = 1;
        mainLight.shadow.camera.far = 50;
        mainLight.shadow.camera.left = -15;
        mainLight.shadow.camera.right = 15;
        mainLight.shadow.camera.top = 15;
        mainLight.shadow.camera.bottom = -15;
        scene.add(mainLight);
        
        const fillLight = new THREE.DirectionalLight(0xcce6ff, 0.9);
        fillLight.position.set(-6, 3, 8);
        scene.add(fillLight);
        
        const backLight = new THREE.DirectionalLight(0x99aacc, 0.7);
        backLight.position.set(-3, 1, -12);
        scene.add(backLight);
        
        const sideLight = new THREE.PointLight(0x88aadd, 0.5);
        sideLight.position.set(0, 4, 12);
        scene.add(sideLight);
        
        const bottomLight = new THREE.PointLight(0x5577aa, 0.3);
        bottomLight.position.set(0, -2, 5);
        scene.add(bottomLight);
        
        // ---------- 4. è¾…åŠ©å·¥å…· ----------
        const gridHelper = new THREE.GridHelper(30, 20, 0x66aaff, 0x446688);
        gridHelper.position.y = 0;
        scene.add(gridHelper);
        
        const axesHelper = new THREE.AxesHelper(12);
        scene.add(axesHelper);
        
        const originDot = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x553300, emissiveIntensity: 0.3 })
        );
        scene.add(originDot);
        
        // ---------- 5. å…¨å±€çŠ¶æ€ ----------
        let currentModel = null;
        const layerMeshesMap = new Map();
        let currentActiveLayer = null;
        let isSplitMode = false;
        let currentExplodeFactor = 1.2;
        
        // ---------- 6. å±‚çº§é…ç½® - å¢å¼ºç‰ˆå‘½ååŒ¹é… ----------
        const layerConfig = [
            { 
                name: 'a1', 
                keywords: ['a1', 'wall', 'å¢™ä½“', 'åŸºå±‚', 'A1'], 
                color: '#6b7c8b', 
                emissive: '#2a3a4a',
                desc: 'åŸºå±‚å¢™ä½“',
                func: 'ç»“æ„åŸºåº•ï¼Œæ‰¿é‡åŠä¼ åŠ›ã€‚'
            },
            { 
                name: 'b1', 
                keywords: ['b1', 'embed', 'é¢„åŸ‹', 'åŸ‹ä»¶', 'B1'], 
                color: '#cccccc', 
                emissive: '#888888',
                desc: 'é¢„åŸ‹ä»¶',
                func: 'ä¸å¢™ä½“é”šå›ºï¼Œè¿æ¥é¾™éª¨çš„é‡‘å±ä»¶ã€‚'
            },
            { 
                name: 'b2', 
                keywords: ['b2', 'vertical', 'ç«–å‘', 'é¾™éª¨_ç«–å‘', 'B2'], 
                color: '#9aa9b9', 
                emissive: '#5f6f7f',
                desc: 'ç«–å‘é¾™éª¨',
                func: 'å‚ç›´ä¸»é¾™éª¨ï¼Œè°ƒèŠ‚å¹³æ•´åº¦ï¼Œæ‰¿å—é£è·è½½ã€‚'
            },
            { 
                name: 'c1', 
                keywords: ['c1', 'horizontal', 'æ¨ªå‘', 'é¾™éª¨_æ¨ªå‘', 'C1'], 
                color: '#9aa9b9', 
                emissive: '#5f6f7f',
                desc: 'æ¨ªå‘é¾™éª¨',
                func: 'æ°´å¹³æ¬¡é¾™éª¨ï¼Œå¢åŠ æ•´ä½“æ€§ã€‚'
            },
            { 
                name: 'c2', 
                keywords: ['c2', 'insulation', 'ä¿æ¸©', 'æŒ¤å¡‘æ¿', 'C2'], 
                color: '#3a7ca5', 
                emissive: '#1e4a6a',
                desc: 'ä¿æ¸©å±‚',
                func: 'ç²˜è´´æˆ–é”šå›ºäºå¢™ä½“ï¼Œä¿æ¸©éš”çƒ­ã€‚'
            },
            { 
                name: 'c3', 
                keywords: ['c3', 'hanger', 'æŒ‚ä»¶', 'çŸ³ææŒ‚ä»¶', 'C3'], 
                color: '#b0b0b0', 
                emissive: '#7a7a7a',
                desc: 'çŸ³ææŒ‚ä»¶',
                func: 'å¯è°ƒæŒ‚ä»¶ï¼Œå›ºå®šçŸ³ææ¿å—ã€‚'
            }
        ];
        
        // ---------- 7. å·¥å…·å‡½æ•° ----------
        function setStatus(message, isError = false) {
            const el = document.getElementById('status-text');
            const icon = document.getElementById('status-icon');
            if (el) el.innerText = message;
            if (icon) icon.innerText = isError ? 'âŒ' : 'âš™ï¸';
            const bar = document.getElementById('status-bar');
            if (bar) bar.style.borderBottomColor = isError ? '#ff4444' : '#00ccff';
            console.log(`[çŠ¶æ€] ${message}`);
        }
        
        // ---------- 8. è¯­éŸ³è®²è§£ ----------
        function speakLayerInfo(layerName) {
            if (!window.speechSynthesis) return;
            const cfg = layerConfig.find(l => l.name === layerName);
            if (!cfg) return;
            
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(`${cfg.desc}ï¼š${cfg.func}`);
            utterance.lang = 'zh-CN';
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        }
        
        // ---------- 9. æ›´æ–°å›¾æ–‡è¯´æ˜ ----------
        function updateDescription(layerName) {
            const descSpan = document.getElementById('extra-desc');
            const titleStrong = document.querySelector('#construction-desc strong');
            const cfg = layerConfig.find(l => l.name === layerName);
            
            if (cfg) {
                titleStrong.innerText = cfg.desc;
                descSpan.innerHTML = `ğŸ”µ é¢œè‰²ï¼š${cfg.color}<br>âš™ï¸ åŠŸèƒ½ï¼š${cfg.func}`;
            } else {
                titleStrong.innerText = 'åŸºå±‚å¢™ä½“';
                descSpan.innerHTML = 'ğŸ”µ é¢œè‰²ï¼š#6b7c8b<br>âš™ï¸ åŠŸèƒ½ï¼šç»“æ„åŸºåº•ï¼Œæ‰¿é‡åŠä¼ åŠ›ã€‚';
            }
        }
        
        // ---------- 10. é€æ˜é«˜äº®ä¿®å¤ç‰ˆ ----------
        function resetAllOpacity() {
            scene.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(mat => {
                        if (mat) {
                            // å…³é”®ä¿®å¤ï¼šç¡®ä¿æè´¨æ”¯æŒé€æ˜
                            mat.transparent = false;
                            mat.opacity = 1.0;
                            mat.needsUpdate = true;
                        }
                    });
                }
            });
            currentActiveLayer = null;
        }
        
        function highlightLayer(layerName) {
            if (!layerName) return;
            
            const meshes = layerMeshesMap.get(layerName) || [];
            console.log(`é«˜äº® ${layerName}: æ‰¾åˆ° ${meshes.length} ä¸ªMesh`);
            
            if (meshes.length === 0) {
                setStatus(`âš ï¸ æœªæ‰¾åˆ°: ${layerName}`, true);
                return;
            }
            
            // ç¬¬ä¸€æ­¥ï¼šæ‰€æœ‰Meshè®¾ä¸ºåŠé€æ˜
            scene.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(mat => {
                        if (mat) {
                            // å…³é”®ï¼šå¿…é¡»è®¾ç½®transparentä¸ºtrueæ‰èƒ½æ˜¾ç¤ºé€æ˜åº¦
                            mat.transparent = true;
                            mat.opacity = 0.22;
                            mat.needsUpdate = true;
                        }
                    });
                }
            });
            
            // ç¬¬äºŒæ­¥ï¼šç›®æ ‡Meshæ¢å¤ä¸é€æ˜
            meshes.forEach(mesh => {
                if (mesh.material) {
                    const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
                    mats.forEach(mat => {
                        if (mat) {
                            mat.transparent = false; // å®Œå…¨ä¸é€æ˜
                            mat.opacity = 1.0;
                            mat.needsUpdate = true;
                        }
                    });
                }
            });
            
            currentActiveLayer = layerName;
            setStatus(`ğŸ”† é«˜äº®: ${layerName} (${layerConfig.find(l => l.name === layerName)?.desc || layerName})`);
            updateDescription(layerName);
        }
        
        // ---------- 11. çˆ†ç‚¸æ‹†åˆ† - åŸºäºåŸç‚¹æ”¾å°„ï¼ˆæ‚¨è¦æ±‚çš„æ–¹æ¡ˆï¼‰----------
        function applyExplode(explodeFactor) {
            if (!currentModel) return;
            
            console.log(`çˆ†ç‚¸å› å­: ${explodeFactor}`);
            
            layerConfig.forEach(layer => {
                const meshes = layerMeshesMap.get(layer.name) || [];
                meshes.forEach(mesh => {
                    if (!mesh.userData.originalPos) {
                        mesh.userData.originalPos = mesh.position.clone();
                    }
                    
                    // è·å–ç‰©ä½“çš„ä¸–ç•Œä¸­å¿ƒç‚¹
                    const box = new THREE.Box3().setFromObject(mesh);
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // æ–¹å‘å‘é‡ï¼šä»åŸç‚¹(0,0,0)æŒ‡å‘ç‰©ä½“ä¸­å¿ƒ
                    let direction;
                    if (center.length() < 0.01) {
                        // å¦‚æœç‰©ä½“å°±åœ¨åŸç‚¹ï¼Œç»™ä¸ªé»˜è®¤æ–¹å‘
                        direction = new THREE.Vector3(1, 0.5, 0.2).normalize();
                    } else {
                        direction = center.clone().normalize();
                    }
                    
                    // åº”ç”¨çˆ†ç‚¸ä½ç§»
                    mesh.position.copy(
                        mesh.userData.originalPos.clone().add(
                            direction.multiplyScalar(explodeFactor)
                        )
                    );
                });
            });
            
            setStatus(`ğŸ’¥ çˆ†ç‚¸è·ç¦»: ${explodeFactor.toFixed(2)}`);
        }
        
        function resetPosition() {
            if (!currentModel) return;
            
            layerConfig.forEach(layer => {
                const meshes = layerMeshesMap.get(layer.name) || [];
                meshes.forEach(mesh => {
                    if (mesh.userData.originalPos) {
                        mesh.position.copy(mesh.userData.originalPos);
                    }
                });
            });
            
            setStatus('ğŸ”¹ å·²å¤ä½');
        }
        
        // ---------- 12. ç”Ÿæˆå±‚æ¬¡æŒ‰é’® ----------
        function generateLayerButtons() {
            const container = document.getElementById('layer-buttons-container');
            if (!container) return;
            container.innerHTML = '';
            
            layerConfig.forEach(layer => {
                const btn = document.createElement('button');
                btn.className = 'layer-btn';
                btn.innerHTML = `<span style="font-size:1.1em;">ğŸ§±</span> ${layer.desc}`;
                btn.dataset.layer = layer.name;
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // è¯­éŸ³
                    speakLayerInfo(layer.name);
                    
                    // é«˜äº®åˆ‡æ¢
                    if (currentActiveLayer === layer.name) {
                        resetAllOpacity();
                        updateDescription('a1');
                        document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                    } else {
                        highlightLayer(layer.name);
                        document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                });
                
                container.appendChild(btn);
            });
        }
        
        // ---------- 13. æ¨¡å‹åŠ è½½ä¸ä¿®å¤ ----------
        setStatus('ğŸš€ åŠ è½½æ¨¡å‹ä¸­...');
        const loader = new FBXLoader();
        const modelUrl = 'https://kutabimvr.github.io/3DmodelV2.0/ceshi.FBX';
        
        loader.load(modelUrl, 
            (object) => {
                setStatus('âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼Œæ­£åœ¨å¤„ç†...');
                
                if (currentModel) scene.remove(currentModel);
                
                // ========== å…³é”®ä¿®å¤ï¼šæ‰å¹³åŒ–å±‚çº§ ==========
                console.log('åŸå§‹ç»“æ„:', object);
                
                // æ”¶é›†æ‰€æœ‰Mesh
                const allMeshes = [];
                object.traverse(child => {
                    if (child.isMesh) {
                        allMeshes.push(child);
                    }
                });
                
                // æ¸…ç©ºåŸæ¨¡å‹
                while(object.children.length > 0) {
                    object.remove(object.children[0]);
                }
                
                // æŠŠæ‰€æœ‰Meshç›´æ¥æ”¾åˆ°æ ¹èŠ‚ç‚¹
                allMeshes.forEach(mesh => {
                    // ä¿å­˜ä¸–ç•Œä½ç½®
                    const worldPos = mesh.getWorldPosition(new THREE.Vector3());
                    const worldRot = mesh.getWorldQuaternion(new THREE.Quaternion());
                    const worldScale = mesh.getWorldScale(new THREE.Vector3());
                    
                    // ä»åŸçˆ¶èŠ‚ç‚¹ç§»é™¤
                    if (mesh.parent) {
                        mesh.parent.remove(mesh);
                    }
                    
                    // æ·»åŠ åˆ°æ ¹èŠ‚ç‚¹
                    object.add(mesh);
                    
                    // æ¢å¤ä¸–ç•Œå˜æ¢
                    mesh.position.copy(worldPos);
                    mesh.quaternion.copy(worldRot);
                    mesh.scale.copy(worldScale);
                    
                    // è®°å½•åŸå§‹ä½ç½®
                    mesh.userData.originalPos = mesh.position.clone();
                    
                    // å…³é”®ï¼šå¼ºåˆ¶æè´¨ç‹¬ç«‹
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material = mesh.material.map(m => m.clone());
                        } else {
                            mesh.material = mesh.material.clone();
                        }
                    }
                });
                
                console.log(`æ‰å¹³åŒ–å®Œæˆï¼Œå…± ${allMeshes.length} ä¸ªç‹¬ç«‹Mesh`);
                
                // ========== æ™ºèƒ½å±…ä¸­ç¼©æ”¾ ==========
                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 0 ? 6.0 / maxDim : 1;
                object.scale.setScalar(scale);
                
                // é‡æ–°è®¡ç®—ç¼©æ”¾åä½ç½®
                const scaledBox = new THREE.Box3().setFromObject(object);
                const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
                
                object.position.x -= scaledCenter.x;
                object.position.y -= scaledCenter.y;
                object.position.z -= scaledCenter.z;
                
                const finalBox = new THREE.Box3().setFromObject(object);
                const minY = finalBox.min.y;
                object.position.y += -minY + 0.15;
                
                // é‡æ–°è®°å½•originalPos
                object.traverse(child => {
                    if (child.isMesh) {
                        child.userData.originalPos = child.position.clone();
                    }
                });
                
                // ========== åŒ¹é…å±‚çº§å¹¶èµ‹äºˆé¢œè‰² ==========
                layerMeshesMap.clear();
                
                object.traverse((child) => {
                    if (!child.isMesh) return;
                    
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    const name = child.name.toLowerCase();
                    let matchedLayer = null;
                    
                    // å¢å¼ºåŒ¹é…ï¼šéå†æ‰€æœ‰å…³é”®è¯
                    for (let layer of layerConfig) {
                        for (let keyword of layer.keywords) {
                            if (name.includes(keyword.toLowerCase())) {
                                matchedLayer = layer;
                                break;
                            }
                        }
                        if (matchedLayer) break;
                    }
                    
                    if (matchedLayer) {
                        // å­˜å‚¨åˆ°æ˜ å°„è¡¨
                        if (!layerMeshesMap.has(matchedLayer.name)) {
                            layerMeshesMap.set(matchedLayer.name, []);
                        }
                        layerMeshesMap.get(matchedLayer.name).push(child);
                        
                        // èµ‹äºˆæè´¨é¢œè‰²
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if (mat) {
                                    const baseColor = new THREE.Color(matchedLayer.color);
                                    mat.color = baseColor;
                                    mat.emissive = new THREE.Color(matchedLayer.emissive || '#222222');
                                    mat.emissiveIntensity = 0.2;
                                    mat.roughness = 0.55;
                                    mat.metalness = 0.25;
                                    mat.needsUpdate = true;
                                }
                            });
                        }
                        
                        console.log(`âœ… åŒ¹é…: ${child.name} â†’ ${matchedLayer.name} (${matchedLayer.desc})`);
                    } else {
                        console.log(`âŒ æœªåŒ¹é…: ${child.name}`);
                        // é»˜è®¤æè´¨
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if (mat) mat.color.setHex(0xaaaaaa);
                            });
                        }
                    }
                });
                
                // æ‰“å°åŒ¹é…ç»Ÿè®¡
                console.log('åŒ¹é…ç»“æœ:');
                layerConfig.forEach(layer => {
                    const count = (layerMeshesMap.get(layer.name) || []).length;
                    console.log(`${layer.name}: ${count}ä¸ªMesh`);
                });
                
                scene.add(object);
                currentModel = object;
                
                generateLayerButtons();
                resetAllOpacity();
                
                // è°ƒæ•´ç›¸æœº
                const viewBox = new THREE.Box3().setFromObject(object);
                const viewCenter = viewBox.getCenter(new THREE.Vector3());
                controls.target.copy(viewCenter);
                camera.position.copy(viewCenter.clone().add(new THREE.Vector3(8, 5, 10)));
                controls.update();
                
                setStatus(`âœ… å°±ç»ª | å·²åŒ¹é… ${Array.from(layerMeshesMap.values()).flat().length} ä¸ªæ„ä»¶`);
                
                // æ˜¾ç¤ºæ»‘åŠ¨æ¡
                document.getElementById('slider-container').style.display = 'flex';
            },
            (progress) => {
                if (progress.lengthComputable) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    setStatus(`â³ åŠ è½½ä¸­ ${percent}%`);
                }
            },
            (error) => {
                console.error('FBXåŠ è½½å¤±è´¥:', error);
                setStatus('âŒ åŠ è½½å¤±è´¥', true);
            }
        );
        
        // ---------- 14. æŒ‰é’®äº‹ä»¶ ----------
        document.getElementById('btn-split').addEventListener('click', () => {
            if (!currentModel) return;
            isSplitMode = true;
            document.getElementById('slider-container').style.display = 'flex';
            const slider = document.getElementById('explode-slider');
            currentExplodeFactor = parseFloat(slider.value);
            applyExplode(currentExplodeFactor);
        });
        
        document.getElementById('btn-assemble').addEventListener('click', () => {
            isSplitMode = false;
            resetPosition();
            resetAllOpacity();
        });
        
        // æ»‘åŠ¨æ¡
        function initSlider() {
            const slider = document.getElementById('explode-slider');
            if (!slider) return;
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                currentExplodeFactor = val;
                if (isSplitMode) {
                    applyExplode(val);
                }
            });
        }
        initSlider();
        
        // ---------- 15. å›¾ç‰‡å¼¹çª—æŒ‰é’®ç§»åˆ°æ ‡é¢˜ä¸‹ ----------
        // å·²åœ¨HTMLä¸­æ‰‹åŠ¨ç§»åŠ¨ï¼Œè¿™é‡Œç»‘å®šäº‹ä»¶
        document.getElementById('img-popup-btn').addEventListener('click', () => {
            const imgUrl = 'https://kutabimvr.github.io/3DmodelV2.0/å¹²æŒ‚çŸ³æ.jpg';
            const popupWin = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
            if (popupWin) {
                popupWin.document.write(`
                    <html>
                    <head><title>æ„é€ è¯¦å›¾</title>
                    <style>
                        body{margin:0;display:flex;justify-content:center;align-items:center;background:#0a141c;}
                        img{max-width:100%; border:5px solid #ffaa00; box-shadow:0 0 30px rgba(255,170,0,0.5);}
                    </style>
                    </head>
                    <body><img src="${imgUrl}" alt="å¹²æŒ‚çŸ³æèŠ‚ç‚¹æ„é€ è¯¦å›¾"></body>
                    </html>
                `);
            } else {
                alert('è¯·å…è®¸å¼¹çª—æŸ¥çœ‹æ„é€ è¯¦å›¾');
            }
        });
        
        // ---------- 16. è¯•é¢˜äº¤äº’ ----------
        const optionItems = document.querySelectorAll('.option-item');
        optionItems.forEach((opt, idx) => {
            opt.addEventListener('click', function() {
                optionItems.forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
                const feedback = document.getElementById('quiz-feedback');
                if (idx === 2) {
                    feedback.innerHTML = 'âœ… å›ç­”æ­£ç¡®ï¼çŸ³ææŒ‚ä»¶æ˜¯è¿æ¥çŸ³æä¸é¾™éª¨çš„å…³é”®å—åŠ›æ„ä»¶ã€‚';
                    feedback.style.borderLeftColor = '#4caf50';
                } else {
                    feedback.innerHTML = 'âŒ å†æƒ³æƒ³ï¼ŒæŒ‚ä»¶æ‰¿æ‹…çŸ³æè·è½½å¹¶ä¼ é€’è‡³é¾™éª¨ã€‚';
                    feedback.style.borderLeftColor = '#ff5555';
                }
            });
        });
        
        // ---------- 17. çª—å£è‡ªé€‚åº” ----------
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        // ---------- 18. åŠ¨ç”» ----------
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // åˆå§‹åŒ–
        updateDescription('a1');
        setStatus('å°±ç»ªï¼Œç­‰å¾…æ¨¡å‹');
    </script>
        // =========================================================================
        // å¹²æŒ‚çŸ³æèŠ‚ç‚¹æ„é€ æ•™å­¦ç³»ç»Ÿ â€”â€” å®Œæ•´ç‰ˆ V3.0 (å‡çº§V2.0æ ·å¼)
        // åŠŸèƒ½ï¼šFBXè‡ªåŠ¨åŠ è½½ã€æ„ä»¶åŒ¹é…ã€é¢œè‰²ã€å±‚æ¬¡é«˜äº®ã€è¯­éŸ³è®²è§£ã€æ»‘åŠ¨æ¡çˆ†ç‚¸æ‹†åˆ†(åŸç‚¹æ”¾å°„)ã€å›¾ç‰‡å¼¹çª—ã€ç‰ˆæœ¬å·
        // ä¿®å¤ï¼šB1é«˜äº®ä¸ç”Ÿæ•ˆé—®é¢˜ï¼Œå–æ¶ˆè‡ªåŠ¨æ—‹è½¬ï¼Œæ‹†åˆ†çˆ†ç‚¸ä»¥åŸç‚¹ä¸ºä¸­å¿ƒå››æ•£
        // =========================================================================
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // ---------- 1. åˆå§‹åŒ–åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨ ----------
        const container = document.getElementById('canvas-container');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101a24); // æ·±æµ·æš—è“ï¼Œå‡¸æ˜¾æ¨¡å‹
        
        const camera = new THREE.PerspectiveCamera(48, container.clientWidth / container.clientHeight, 0.01, 1000);
        camera.position.set(7, 5, 14);
        camera.lookAt(0, 1.5, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);
        
        // ---------- 2. æ§åˆ¶å™¨ (å…³é—­è‡ªåŠ¨æ—‹è½¬) ----------
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = false;      // å–æ¶ˆè‡ªåŠ¨æ—‹è½¬ï¼Œæ»¡è¶³è¦æ±‚
        controls.autoRotateSpeed = 1.3;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.target.set(0, 1.5, 0);
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 3;
        controls.maxDistance = 200;
        
        // ---------- 3. ç¯å…‰ç³»ç»Ÿï¼šæ˜äº®ä¸”ç«‹ä½“ ----------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffeedd, 1.4);
        mainLight.position.set(4, 8, 10);
        mainLight.castShadow = true;
        mainLight.receiveShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        mainLight.shadow.camera.near = 1;
        mainLight.shadow.camera.far = 50;
        mainLight.shadow.camera.left = -15;
        mainLight.shadow.camera.right = 15;
        mainLight.shadow.camera.top = 15;
        mainLight.shadow.camera.bottom = -15;
        scene.add(mainLight);
        
        const fillLight = new THREE.DirectionalLight(0xcce6ff, 0.9);
        fillLight.position.set(-6, 3, 8);
        scene.add(fillLight);
        
        const backLight = new THREE.DirectionalLight(0x99aacc, 0.7);
        backLight.position.set(-3, 1, -12);
        scene.add(backLight);
        
        const sideLight = new THREE.PointLight(0x88aadd, 0.5);
        sideLight.position.set(0, 4, 12);
        scene.add(sideLight);
        
        const bottomLight = new THREE.PointLight(0x5577aa, 0.3);
        bottomLight.position.set(0, -2, 5);
        scene.add(bottomLight);
        
        // ---------- 4. è¾…åŠ©å·¥å…·ï¼ˆæ˜¾çœ¼çš„ç½‘æ ¼+è½´çº¿ï¼‰---------
        const gridHelper = new THREE.GridHelper(30, 20, 0x66aaff, 0x446688);
        gridHelper.position.y = 0;
        scene.add(gridHelper);
        
        const axesHelper = new THREE.AxesHelper(12);
        scene.add(axesHelper);
        
        const originDot = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x553300, emissiveIntensity: 0.3 })
        );
        scene.add(originDot);
        
        // ---------- 5. å…¨å±€çŠ¶æ€ ----------
        let currentModel = null;               // å½“å‰åŠ è½½çš„æ¨¡å‹
        const layerMeshesMap = new Map();      // å­˜å‚¨æ¯ä¸ªå±‚çº§å¯¹åº”çš„meshæ•°ç»„
        let currentActiveLayer = null;         // å½“å‰é«˜äº®çš„å±‚çº§
        let isSplitMode = false;              // æ˜¯å¦æ‹†åˆ†æ¨¡å¼
        let currentExplodeFactor = 1.2;       // é»˜è®¤çˆ†ç‚¸å› å­
        
        // ---------- 6. å±‚çº§é…ç½®ï¼ˆä¸¥æ ¼æŒ‰ç…§ç”¨æˆ·æä¾›çš„å‘½åå’Œé¢œè‰²ï¼‰---------
        const layerConfig = [
            { name: 'a1', keyword: 'a1', color: '#6b7c8b', emissive: '#2a3a4a' },
            { name: 'b1', keyword: 'b1', color: '#cccccc', emissive: '#888888' },
            { name: 'b2', keyword: 'b2', color: '#9aa9b9', emissive: '#5f6f7f' },
            { name: 'c1', keyword: 'c1', color: '#9aa9b9', emissive: '#5f6f7f' },
            { name: 'c2', keyword: 'c2', color: '#3a7ca5', emissive: '#1e4a6a' },
            { name: 'c3', keyword: 'c3', color: '#b0b0b0', emissive: '#7a7a7a' },
        ];
        
        // å½’ä¸€åŒ–çš„çˆ†ç‚¸æ–¹å‘å‘é‡ï¼ˆåŸºäºåŸç‚¹ï¼‰
        // æˆ‘ä»¬ä¸ºæ¯ä¸ªæ„ä»¶è®¾ç½®ä¸åŒçš„æ–¹å‘ï¼Œä½¿å…¶ä»¥åŸç‚¹ä¸ºä¸­å¿ƒå‘å¤–æ”¾å°„
        // æ²¡æœ‰é¢„å®šä¹‰æ–¹å‘çš„ï¼Œæ ¹æ®å…¶åŸå§‹ä½ç½®å½’ä¸€åŒ–å‘é‡
        const customDirections = {
            'a1': new THREE.Vector3(0.2, 0.8, 0.2).normalize(),
            'b1': new THREE.Vector3(0.9, -0.1, 0.3).normalize(),
            'b2': new THREE.Vector3(0.5, 0.4, -0.7).normalize(),
            'c1': new THREE.Vector3(-0.6, 0.5, 0.5).normalize(),
            'c2': new THREE.Vector3(0.3, -0.2, 0.9).normalize(),
            'c3': new THREE.Vector3(-0.7, 0.1, -0.6).normalize(),
        };
        
        // ---------- 7. å·¥å…·å‡½æ•°ï¼šæ›´æ–°çŠ¶æ€æ  ----------
        function setStatus(message, isError = false) {
            const el = document.getElementById('status-text');
            const icon = document.getElementById('status-icon');
            if (el) el.innerText = message;
            if (icon) icon.innerText = isError ? 'âŒ' : 'âš™ï¸';
            const bar = document.getElementById('status-bar');
            if (bar) bar.style.borderBottomColor = isError ? '#ff4444' : '#00ccff';
            console.log(`[çŠ¶æ€] ${message}`);
        }
        
        // ---------- 8. è¯­éŸ³è®²è§£ï¼ˆä¸­æ–‡ï¼‰---------
        function speakLayerInfo(layerName) {
            if (!window.speechSynthesis) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³API');
                return;
            }
            let detail = '';
            switch(layerName) {
                case 'a1': detail = 'a1ï¼ŒåŸºå±‚å¢™ä½“ï¼Œç°è‰²ï¼Œç»“æ„åŸºç¡€ã€‚'; break;
                case 'b1': detail = 'b1ï¼Œé¢„åŸ‹ä»¶ï¼Œé‡‘å±åˆ¶ï¼Œæå‰åŸ‹è®¾äºå¢™ä½“ï¼Œç”¨äºè¿æ¥é¾™éª¨ã€‚'; break;
                case 'b2': detail = 'b2ï¼Œç«–å‘é¾™éª¨ï¼Œä¸»è¦å—åŠ›æ„ä»¶ï¼Œä¸é¢„åŸ‹ä»¶å›ºå®šã€‚'; break;
                case 'c1': detail = 'c1ï¼Œæ¨ªå‘é¾™éª¨ï¼Œæ°´å¹³æ”¯æ’‘ï¼Œå¢å¼ºç¨³å®šæ€§ã€‚'; break;
                case 'c2': detail = 'c2ï¼Œä¿æ¸©å±‚ï¼ŒæŒ¤å¡‘æ¿ï¼Œè“è‰²ï¼Œéš”çƒ­èŠ‚èƒ½ã€‚'; break;
                case 'c3': detail = 'c3ï¼ŒçŸ³ææŒ‚ä»¶ï¼Œä¸é”ˆé’¢ç­‰é‡‘å±ï¼Œè¿æ¥çŸ³æä¸é¾™éª¨ã€‚'; break;
                default: detail = layerName;
            }
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(`${layerName}ï¼š${detail}`);
            utterance.lang = 'zh-CN';
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            window.speechSynthesis.speak(utterance);
        }
        
        // ---------- 9. æ›´æ–°å›¾æ–‡è¯´æ˜åŒº ----------
        function updateDescription(layerName) {
            const descSpan = document.getElementById('extra-desc');
            const titleStrong = document.querySelector('#construction-desc strong');
            const cfg = layerConfig.find(l => l.name === layerName);
            if (cfg) {
                titleStrong.innerText = cfg.name;
                let colorDesc = '';
                let funcDesc = '';
                switch(cfg.name) {
                    case 'a1': colorDesc = 'ç°è‰² #6b7c8b'; funcDesc = 'ç»“æ„åŸºåº•ï¼Œæ‰¿é‡åŠä¼ åŠ›ã€‚'; break;
                    case 'b1': colorDesc = 'é‡‘å±è‰² #cccccc'; funcDesc = 'ä¸å¢™ä½“é”šå›ºï¼Œè¿æ¥é¾™éª¨çš„é‡‘å±ä»¶ã€‚'; break;
                    case 'b2': colorDesc = 'é“¶è‰² #9aa9b9'; funcDesc = 'å‚ç›´ä¸»é¾™éª¨ï¼Œè°ƒèŠ‚å¹³æ•´åº¦ï¼Œæ‰¿å—é£è·è½½ã€‚'; break;
                    case 'c1': colorDesc = 'é“¶è‰² #9aa9b9'; funcDesc = 'æ°´å¹³æ¬¡é¾™éª¨ï¼Œå¢åŠ æ•´ä½“æ€§ã€‚'; break;
                    case 'c2': colorDesc = 'è“è‰² #3a7ca5'; funcDesc = 'ç²˜è´´æˆ–é”šå›ºäºå¢™ä½“ï¼Œä¿æ¸©éš”çƒ­ã€‚'; break;
                    case 'c3': colorDesc = 'é‡‘å±è‰² #b0b0b0'; funcDesc = 'å¯è°ƒæŒ‚ä»¶ï¼Œå›ºå®šçŸ³ææ¿å—ã€‚'; break;
                }
                descSpan.innerHTML = `é¢œè‰²å»ºè®®ï¼š${colorDesc}<br>åŠŸèƒ½ï¼š${funcDesc}`;
            }
        }
        
        // ---------- 10. é«˜äº®/å–æ¶ˆé«˜äº®é€»è¾‘ (ä¿®å¤B1ä¸é€æ˜bug) ----------
        function resetAllOpacity() {
            scene.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(mat => {
                        if (mat) {
                            mat.opacity = 1.0;
                            mat.transparent = false;
                        }
                    });
                }
            });
            currentActiveLayer = null;
        }
        
        function highlightLayer(layerName) {
            // å…ˆé‡ç½®æ‰€æœ‰ä¸é€æ˜
            resetAllOpacity();
            if (!layerName) return;
            
            const meshes = layerMeshesMap.get(layerName) || [];
            if (meshes.length === 0) {
                setStatus(`æœªæ‰¾åˆ°: ${layerName}`, true);
                return;
            }
            
            // å†æ¬¡éå†ç¡®ä¿åªé«˜äº®ç›®æ ‡meshï¼Œå…¶ä½™åŠé€æ˜ã€‚æ›´å¯é æ–¹æ³•ï¼šè®¾ç½®æ‰€æœ‰meshé€æ˜åº¦ï¼Œå†ä¸“é—¨å¤åŸç›®æ ‡mesh
            scene.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    const isTarget = meshes.includes(obj);
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(mat => {
                        if (mat) {
                            mat.opacity = isTarget ? 1.0 : 0.22;
                            mat.transparent = !isTarget;
                        }
                    });
                }
            });
            
            currentActiveLayer = layerName;
            setStatus(`é«˜äº®: ${layerName}`);
            updateDescription(layerName);
        }
        
        // ---------- 11. ä»¥åŸç‚¹ä¸ºä¸­å¿ƒçš„çˆ†ç‚¸æ‹†åˆ†/ç»„è£… (æ»‘åŠ¨æ¡æ§åˆ¶è·ç¦») ----------
        function applyExplode(explodeFactor) {
            if (!currentModel) return;
            
            layerConfig.forEach(layer => {
                const meshes = layerMeshesMap.get(layer.name) || [];
                meshes.forEach(mesh => {
                    if (!mesh.userData.originalPos) {
                        mesh.userData.originalPos = mesh.position.clone();
                    }
                    // è®¡ç®—æ–¹å‘ï¼šä¼˜å…ˆè‡ªå®šä¹‰ï¼Œå¦åˆ™æ ¹æ®åŸå§‹ä½ç½®ç›¸å¯¹åŸç‚¹
                    let dir;
                    if (customDirections[layer.name]) {
                        dir = customDirections[layer.name].clone();
                    } else {
                        // è‹¥åŸå§‹ä½ç½®æ˜¯é›¶å‘é‡ï¼Œåˆ™ç»™ä¸ªéšæœºæ–¹å‘
                        if (mesh.userData.originalPos.lengthSq() === 0) {
                            dir = new THREE.Vector3(1, 0, 0);
                        } else {
                            dir = mesh.userData.originalPos.clone().normalize();
                        }
                    }
                    // ç§»åŠ¨ä½ç½®ï¼šåŸå§‹ä½ç½® + æ–¹å‘ * çˆ†ç‚¸å› å­
                    mesh.position.copy(mesh.userData.originalPos.clone().add(dir.multiplyScalar(explodeFactor)));
                });
            });
            setStatus(`çˆ†ç‚¸è·ç¦»: ${explodeFactor.toFixed(2)}`);
        }
        
        function resetPosition() {
            if (!currentModel) return;
            layerConfig.forEach(layer => {
                const meshes = layerMeshesMap.get(layer.name) || [];
                meshes.forEach(mesh => {
                    if (mesh.userData.originalPos) {
                        mesh.position.copy(mesh.userData.originalPos);
                    }
                });
            });
            setStatus('ç»„è£…å¤ä½');
        }
        
        // æ»‘åŠ¨æ¡äº‹ä»¶ç›‘å¬
        function initSlider() {
            const slider = document.getElementById('explode-slider');
            if (!slider) return;
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                currentExplodeFactor = val;
                if (isSplitMode) {
                    applyExplode(val);
                }
            });
        }
        
        // ---------- 12. ç”Ÿæˆå±‚æ¬¡æŒ‰é’®ï¼ˆåŠ¨æ€ï¼‰---------
        function generateLayerButtons() {
            const container = document.getElementById('layer-buttons-container');
            if (!container) return;
            container.innerHTML = '';
            
            layerConfig.forEach(layer => {
                const btn = document.createElement('button');
                btn.className = 'layer-btn';
                btn.innerHTML = `<span style="font-size:1.1em;">ğŸ§±</span> ${layer.name}`;
                btn.dataset.layer = layer.name;
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    speakLayerInfo(layer.name);
                    
                    if (currentActiveLayer === layer.name) {
                        resetAllOpacity();
                        updateDescription('åŸºå±‚å¢™ä½“');
                        btn.classList.remove('active');
                    } else {
                        highlightLayer(layer.name);
                        document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                });
                container.appendChild(btn);
            });
        }
        
        // ---------- 13. æ ¸å¿ƒï¼šåŠ è½½FBXæ¨¡å‹ï¼Œåº”ç”¨é¢œè‰²ã€åŒ¹é…æ„ä»¶ã€å±…ä¸­ä¼˜åŒ– ----------
        setStatus('ğŸš€ æ­£åœ¨è¿æ¥æœåŠ¡å™¨åŠ è½½æ¨¡å‹...');
        const loader = new FBXLoader();
        const modelUrl = 'https://kutabimvr.github.io/3DmodelV2.0/ceshi.FBX';
        
        loader.load(modelUrl, 
            (object) => {
                setStatus('âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼Œæ­£åœ¨åŒ¹é…æ„ä»¶ä¸é¢œè‰²...');
                console.log('FBXå¯¹è±¡:', object);
                
                if (currentModel) scene.remove(currentModel);
                
                // ä¿å­˜åŸå§‹ä½ç½®ï¼ˆç”¨äºæ‹†åˆ†çˆ†ç‚¸ï¼‰
                object.traverse(child => {
                    if (child.isMesh) {
                        child.userData.originalPos = child.position.clone();
                    }
                });
                
                // æ™ºèƒ½å±…ä¸­ä¸ç¼©æ”¾
                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 0 ? 6.0 / maxDim : 1;
                object.scale.setScalar(scale);
                
                const scaledBox = new THREE.Box3().setFromObject(object);
                const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
                
                object.position.x -= scaledCenter.x;
                object.position.y -= scaledCenter.y;
                object.position.z -= scaledCenter.z;
                
                const finalBox = new THREE.Box3().setFromObject(object);
                const minY = finalBox.min.y;
                object.position.y += -minY + 0.15;
                
                // é‡æ–°è®°å½•originalPos (å› ä¸ºç¼©æ”¾ç§»åŠ¨åä½ç½®å˜äº†)
                object.traverse(child => {
                    if (child.isMesh) {
                        child.userData.originalPos = child.position.clone();
                    }
                });
                
                // åŒ¹é…å‘½åå¹¶èµ‹äºˆé¢œè‰²
                object.traverse((child) => {
                    if (!child.isMesh) return;
                    
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    const name = child.name;
                    let matchedLayer = null;
                    
                    for (let layer of layerConfig) {
                        if (name.includes(layer.keyword) || 
                            name.includes(layer.keyword.toUpperCase()) ||
                            name.includes(layer.keyword.replace('_', ''))) {
                            matchedLayer = layer;
                            break;
                        }
                    }
                    
                    if (matchedLayer) {
                        if (!layerMeshesMap.has(matchedLayer.name)) {
                            layerMeshesMap.set(matchedLayer.name, []);
                        }
                        layerMeshesMap.get(matchedLayer.name).push(child);
                        
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if (mat) {
                                    const baseColor = new THREE.Color(matchedLayer.color);
                                    baseColor.multiplyScalar(1.2);
                                    mat.color = baseColor;
                                    mat.emissive = new THREE.Color(matchedLayer.emissive || '#222222');
                                    mat.emissiveIntensity = 0.2;
                                    mat.roughness = 0.55;
                                    mat.metalness = 0.25;
                                }
                            });
                        }
                    } else {
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if (mat) mat.color.setHex(0xaaaaaa);
                            });
                        }
                    }
                });
                
                scene.add(object);
                currentModel = object;
                
                // è°ƒè¯•ï¼šæ£€æŸ¥b1æ˜¯å¦æœ‰mesh
                console.log('B1 meshes:', layerMeshesMap.get('b1'));
                
                generateLayerButtons();
                resetAllOpacity();
                
                const viewBox = new THREE.Box3().setFromObject(object);
                const viewCenter = viewBox.getCenter(new THREE.Vector3());
                controls.target.copy(viewCenter);
                camera.position.copy(viewCenter.clone().add(new THREE.Vector3(8, 5, 10)));
                controls.update();
                
                setStatus(`âœ… å°±ç»ª | æ„ä»¶å·²åˆ†ç±»ï¼Œå¯ç‚¹å‡»å±‚æ¬¡é«˜äº®`);
                
                // æ˜¾ç¤ºæ»‘åŠ¨æ¡åŒºåŸŸ
                document.getElementById('slider-container').style.display = 'flex';
                initSlider();
            },
            (progress) => {
                if (progress.lengthComputable) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    setStatus(`â³ åŠ è½½ä¸­ ${percent}%`);
                }
            },
            (error) => {
                console.error('FBXåŠ è½½å¤±è´¥:', error);
                setStatus('âŒ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–è·¯å¾„', true);
            }
        );
        
        // ---------- 14. æŒ‰é’®äº‹ä»¶ç»‘å®š ----------
        document.getElementById('btn-split').addEventListener('click', () => {
            if (!currentModel) return;
            isSplitMode = true;
            // æ˜¾ç¤ºæ»‘åŠ¨æ¡å¹¶åº”ç”¨å½“å‰æ»‘åŠ¨æ¡å€¼
            document.getElementById('slider-container').style.display = 'flex';
            const slider = document.getElementById('explode-slider');
            currentExplodeFactor = parseFloat(slider.value);
            applyExplode(currentExplodeFactor);
            setStatus(`ğŸ’¥ çˆ†ç‚¸æ¨¡å¼ï¼Œè·ç¦» ${currentExplodeFactor.toFixed(2)}`);
        });
        
        document.getElementById('btn-assemble').addEventListener('click', () => {
            isSplitMode = false;
            resetPosition();
            resetAllOpacity(); 
            // éšè—æ»‘åŠ¨æ¡ï¼ˆä¹Ÿå¯ä¿ç•™ï¼Œä½†ä¸ºäº†ç•Œé¢æ•´æ´å¯ä¿ç•™ï¼‰
            // document.getElementById('slider-container').style.display = 'none';
        });
        
        // ---------- 15. è¯•é¢˜äº¤äº’ ----------
        const optionItems = document.querySelectorAll('.option-item');
        optionItems.forEach((opt, idx) => {
            opt.addEventListener('click', function() {
                optionItems.forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
                const feedback = document.getElementById('quiz-feedback');
                if (idx === 2) { // çŸ³ææŒ‚ä»¶
                    feedback.innerHTML = 'âœ… å›ç­”æ­£ç¡®ï¼çŸ³ææŒ‚ä»¶æ˜¯è¿æ¥çŸ³æä¸é¾™éª¨çš„å…³é”®å—åŠ›æ„ä»¶ã€‚';
                    feedback.style.borderLeftColor = '#4caf50';
                } else {
                    feedback.innerHTML = 'âŒ å†æƒ³æƒ³ï¼ŒæŒ‚ä»¶æ‰¿æ‹…çŸ³æè·è½½å¹¶ä¼ é€’è‡³é¾™éª¨ã€‚';
                    feedback.style.borderLeftColor = '#ff5555';
                }
            });
        });
        
        // ---------- 16. å›¾ç‰‡å¼¹çª—ï¼ˆæ–°åŠŸèƒ½ï¼‰---------
        document.getElementById('img-popup-btn').addEventListener('click', () => {
            // åˆ›å»ºä¸€ä¸ªå¼¹çª—æ˜¾ç¤ºå›¾ç‰‡ï¼ˆæ¨¡æ‹Ÿæ¨¡æ€æ¡†ï¼‰
            const imgUrl = 'https://kutabimvr.github.io/3DmodelV2.0/å¹²æŒ‚çŸ³æ.jpg'; // ç¤ºä¾‹å›¾ï¼Œå¯æ›´æ¢
            const popupWin = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
            if (popupWin) {
                popupWin.document.write(`
                    <html><head><title>æ„é€ è¯¦å›¾</title><style>body{margin:0;display:flex;justify-content:center;align-items:center;background:#0a141c;}</style></head>
                    <body><img src="${imgUrl}" style="max-width:100%; border:5px solid #ffaa00;"></body>
                `);
            } else {
                alert('è¯·å…è®¸å¼¹çª—ä»¥æŸ¥çœ‹å›¾ç‰‡ã€‚\næ„é€ è¯¦å›¾ï¼šå¹²æŒ‚çŸ³æèŠ‚ç‚¹å‰–é€è§†ã€‚');
            }
        });
        
        // ---------- 17. è‡ªé€‚åº”çª—å£ ----------
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        
        // ---------- 18. åŠ¨ç”»å¾ªç¯ ----------
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // è‡ªåŠ¨æ—‹è½¬å·²false
            renderer.render(scene, camera);
        }
        animate();
        
        // åˆå§‹åŒ–é»˜è®¤æè¿°
        updateDescription('a1');
        setStatus('å°±ç»ªï¼Œç­‰å¾…æ¨¡å‹');
    </script>
</body>
</html>